function filterstruct = mfiltercreate(type, bandtype, samplefreq, order, rp_db, rs_db, numer, denom, npoints, lowercutoff_hz, highercutoff_hz, infoflag);% function filterstruct = mfiltercreate(type, bandtype, samplefreq, order, rp_db, rs_db, numer, denom, npoints, lowercutoff_hz, highercutoff_hz, infoflag);%%------------------------------------------------% Stores a set of nuemrator and denominator coefficients% (from, say, butter) in a 'filter structure'%------------------------------------------------% % Input parameters%   type            = 'butterworth', 'elliptic' etc%   bandtype        = subclass e.g. 'bandstop', %   samplefreq      = sampling freq, Hz%   order           = Order of filter (Butterworth, Elliptic, Chebyshev)%   rp_db           = ripple depth = peak-to-peak ripples, Rp  (dB) (Elliptic, Chebyshev)%   rs              = 'miminim stopband attenuation', Rs (dB) (Eliiptic)%   numer           = vector of numerator coefficients from 'butter' etc%   denom           = vector of denominator coefficients from 'butter' etc%   npoints         = numberofpoints to use in the measurements of the filter%   lowercutoff_hz  = lower filter cutoff frequency in Hz%   highercutoff_hz = higher filter cutoff frequency in Hz  %   infoflag   = 0, 1;%%% Output%   A special structure containing the important bit (the filter coefficients)%   together with various measurements (e.g. freq responses) done too%   To convolve with a 'wave' sound, use 'mwavefilter'%   To plot the pictures, use 'mfilterplot'%%% Example: see this code in mbutterworth:%  npoints = 512;%  if infoflag >= 1;%     fprintf('storing in filterstructure using %-d point analyses ... \n', npoints);%  end;%  filterstruct = mfiltercreate('butterworth', typeswitch, samplingfreq, rp_db, rs_db, order, numer, denom, npoints,lowercutoff_hz, highercutoff_hz, infoflag);%%  f = %                  type: 'butterworth'%                  band: 'lowpass'%            samplefreq: 20000%                 order: 8%                 rp_db: []%                 rs_db: []%                 numer: [1.7626e-007 1.4100e-006 4.9352e-006 9.8703e-006 1.2338e-005 9.8703e-006 4.9352e-006 1.4100e-006 1.7626e-007]%                 denom: [1 -6.3904 18.0003 -29.1711 29.7314 -19.5056 8.0410 -1.9037 0.1981]%           resp_hzaxis: [512x1 double]%        magresp_linear: [512x1 double]%            magresp_db: [512x1 double]%        phaseresp_degs: [512x1 double]% phaseresp_unwrap_degs: [512x1 double]%      grpdelay_samples: [512x1 double]%           grpdelay_ms: [512x1 double]%                   imp: [164x1 double]%       imp_sampletimes: [164x1 double]%    imp_sampletimes_ms: [164x1 double]%%----------------------------------------------------------------% Original version % MAA Summer 2002 (September 20th 2002)%% updates% MAA Autumn 2002 (1x02)% Added unwrapped phase response %% updates% GG Autumn 2004 (28ix2004)% Saving the lower and higher filter cutoff frequency% MAA Autumn 2004 (29ix04)% not all calls of this program have a lower and higher cutoff (eg mhrtf_mit_compact)% to cope with this, have added a check on the number-of-input params:% if its 10 then they're not specified, so make them up!%----------------------------------------------------------------% ******************************************************************% This MATLAB software was developed by Michael A Akeroyd for % supporting research at the University of Connecticut,% the University of Sussex and the MRC Institute% of Hearing Research. It is made available% in the hope that it may prove useful. % % Any for-profit use or redistribution is prohibited. No warranty% is expressed or implied. All rights reserved.% %    Contact address:%      Dr Michael A Akeroyd,%      MRC Institute of Hearing Research%      Glasgow Royal Infirmary %      (Queen Elizabeth Building)%      16 Alexandra Parade%      Glasgow G31 2ER%      United Kingdom%%      maa@ihr.gla.ac.uk%      http://www.ihr.gla.ac.uk% ******************************************************************% stuff on how the filter was made ...filterstruct.type            = type;% MAA Autumn 2004 (29ix04)if nargin >=12    filterstruct.lowercutoff_hz  = lowercutoff_hz;   filterstruct.highercutoff_hz = highercutoff_hz;else   % for backward compatibility ...   filterstruct.lowercutoff_hz  = [];   filterstruct.highercutoff_hz = [];   % and now lowercutoff is the last param, but it needs to be infoflag ...   infoflag = lowercutoff_hz;end;filterstruct.band            = bandtype;filterstruct.samplefreq      = samplefreq;filterstruct.order           = order;filterstruct.rp_db           = rp_db;filterstruct.rs_db           = rs_db;% filter coefficients ...filterstruct.numer = numer;filterstruct.denom = denom;% measure the freq responses ...if infoflag >=2   fprintf('  measuring filter responses at %d points ...', npoints);end;if infoflag >=2   fprintf('''freqz'' ');end;[h, w] = freqz(filterstruct.numer, filterstruct.denom, npoints);nyquistfreq = samplefreq/2;filterstruct.resp_hzaxis = w/pi * nyquistfreq;filterstruct.magresp_linear = abs(h);% turn the warnings off to stop any zeroswarning off;filterstruct.magresp_db = 20*log10(filterstruct.magresp_linear);warning on;filterstruct.phaseresp_degs = angle(h)/(2*pi)*360.0;% unwrap the phase response toofilterstruct.phaseresp_unwrap_degs = unwrap(angle(h))/(2*pi)*360.0;if infoflag >=2   fprintf('''grpdelay'' ');end;warning off;filterstruct.grpdelay_samples = grpdelay(filterstruct.numer, filterstruct.denom, npoints);filterstruct.grpdelay_ms = filterstruct.grpdelay_samples/samplefreq*1000;warning on;if infoflag >=2   fprintf('''impz'' ');end;[filterstruct.imp, filterstruct.imp_sampletimes] = impz(filterstruct.numer, filterstruct.denom);filterstruct.imp_sampletimes_ms = filterstruct.imp_sampletimes/samplefreq*1000;if infoflag >=2   fprintf('\n');end;% the end!%--------------------------